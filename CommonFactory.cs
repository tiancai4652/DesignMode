using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ClassLibrary1
{
    public class Proxy : DesignModeBase
    {
        public Proxy()
        {
            Name = "代理模式";
            Description = "在软件开发过程中，有些对象有时候会由于网络或其他的障碍，以至于不能够或者不能直接访问到这些对象，如果直接访问对象给系统带来不必要的复杂性，这时候可以在客户端和目标对象之间增加一层中间层，让代理对象代替目标对象，然后客户端只需要访问代理对象，由代理对象去帮我们去请求目标对象并返回结果给客户端";
            Why = "就是给某一个对象提供一个代理，并由代理对象控制对原对象的引用。在一些情况下，一个客户不想或者不能直接引用一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。例如电脑桌面的快捷方式就是一个代理对象，快捷方式是它所引用的程序的一个代理。" ;


            Advantage = new List<string>();
            Advantage.Add("代理模式能够将调用用于真正被调用的对象隔离，在一定程度上降低了系统的耦合度");
            Advantage.Add("代理对象在客户端和目标对象之间起到一个中介的作用，这样可以起到对目标对象的保护。代理对象可以在对目标对象发出请求之前进行一个额外的操作，例如权限检查等");

            Weakness = new List<string>();
            Weakness.Add("由于在客户端和真实主题之间增加了一个代理对象，所以会造成请求的处理速度变慢");
            Weakness.Add("实现代理类也需要额外的工作，从而增加了系统的实现复杂度");

            Tips = new List<Tips>();
            Tips.Add(new ClassLibrary1.Tips() {
                Question = "适配模式，装饰器模式，代理模式区别",
                Answer = "适配模式是为了整合现有不同接口类而搞出一个有共同接口的包装类，如sql ，oracle提供接口不同，我们可以搞个DBAdapter可以适应他们。装饰器模式是为了扩展类的功能却不使用继承，当扩展功能太多，继承实现所有功能但不是所有功能我们都会用，是的类非常臃肿。装饰器模式思想是类要扩展啥功能就通过构造函数注入进行装饰。代理模式就是使用代理把被代理与用户隔离，代理把被代理有相同接口，代理比被代理多做一些不方便做的事。"
            });


            implementation = "在代理类里添加真实类实例，有真实类去做事，代理类去暴露接口。在现实生活中，如果有同事出国或者朋友出国的情况下，我们经常会拖这位朋友帮忙带一些电子产品或化妆品等东西，这个场景中，出国的朋友就是一个代理，他（她）是他（她）朋友的一个代理，由于他朋友不能去国外买东西，他却可以，所以朋友们都托他帮忙带一些东西的";
        }



    }
}
